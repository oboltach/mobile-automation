"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalFfmpegCheck = exports.OptionalFfmpegCheck = exports.optionalApplesimutilsCheck = exports.OptionalApplesimutilsCommandCheck = exports.optionalSimulatorCheck = exports.OptionalSimulatorCheck = exports.optionalIdbCheck = exports.OptionalIdbCommandCheck = void 0;
const utils_1 = require("./utils");
const support_1 = require("appium/support");
require("@colors/colors");
const teen_process_1 = require("teen_process");
class OptionalIdbCommandCheck {
    log;
    static IDB_README_URL = 'https://git.io/JnxQc';
    async diagnose() {
        const fbIdbPath = await (0, utils_1.resolveExecutablePath)('idb');
        const fbCompanionIdbPath = await (0, utils_1.resolveExecutablePath)('idb_companion');
        if (fbIdbPath && fbCompanionIdbPath) {
            return support_1.doctor.okOptional('idb and idb_companion are installed');
        }
        if (!fbIdbPath && fbCompanionIdbPath) {
            return support_1.doctor.nokOptional('idb is not installed');
        }
        else if (fbIdbPath && !fbCompanionIdbPath) {
            return support_1.doctor.nokOptional('idb_companion is not installed');
        }
        return support_1.doctor.nokOptional('idb and idb_companion are not installed');
    }
    async fix() {
        return `Why ${'idb'.bold} is needed and how to install it: ${OptionalIdbCommandCheck.IDB_README_URL}`;
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
}
exports.OptionalIdbCommandCheck = OptionalIdbCommandCheck;
exports.optionalIdbCheck = new OptionalIdbCommandCheck();
class OptionalSimulatorCheck {
    log;
    static SUPPORTED_SIMULATOR_PLATFORMS = [
        {
            displayName: 'iOS',
            name: 'iphonesimulator'
        },
        {
            displayName: 'tvOS',
            name: 'appletvsimulator'
        }
    ];
    async diagnose() {
        try {
            // https://github.com/appium/appium/issues/12093#issuecomment-459358120
            await (0, teen_process_1.exec)('xcrun', ['simctl', 'help']);
        }
        catch (err) {
            return support_1.doctor.nokOptional(`Testing on Simulator is not possible. Cannot run 'xcrun simctl': ${err.stderr || err.message}`);
        }
        const sdks = await this._listInstalledSdks();
        for (const { displayName, name } of OptionalSimulatorCheck.SUPPORTED_SIMULATOR_PLATFORMS) {
            const errorPrefix = `Testing on ${displayName} Simulator is not possible`;
            if (!sdks.some(({ platform }) => platform === name)) {
                return support_1.doctor.nokOptional(`${errorPrefix}: SDK is not installed`);
            }
        }
        return support_1.doctor.okOptional(`The following Simulator SDKs are installed:\n` +
            sdks
                .filter(({ platform }) => OptionalSimulatorCheck.SUPPORTED_SIMULATOR_PLATFORMS.some(({ name }) => name === platform))
                .map(({ displayName }) => `\tâ†’ ${displayName}`).join('\n'));
    }
    async fix() {
        return `Install the desired Simulator SDK from Xcode's Settings -> Components`;
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
    async _listInstalledSdks() {
        const { stdout } = await (0, teen_process_1.exec)('xcodebuild', ['-json', '-showsdks']);
        return JSON.parse(stdout);
    }
}
exports.OptionalSimulatorCheck = OptionalSimulatorCheck;
exports.optionalSimulatorCheck = new OptionalSimulatorCheck();
class OptionalApplesimutilsCommandCheck {
    log;
    static README_LINK = 'https://github.com/appium/appium-xcuitest-driver/blob/master/docs/reference/execute-methods.md#mobile-setpermission';
    async diagnose() {
        const applesimutilsPath = await (0, utils_1.resolveExecutablePath)('applesimutils');
        return applesimutilsPath
            ? support_1.doctor.okOptional(`applesimutils is installed at: ${applesimutilsPath}`)
            : support_1.doctor.nokOptional('applesimutils are not installed');
    }
    async fix() {
        return `Why ${'applesimutils'.bold} is needed and how to install it: ${OptionalApplesimutilsCommandCheck.README_LINK}`;
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
}
exports.OptionalApplesimutilsCommandCheck = OptionalApplesimutilsCommandCheck;
exports.optionalApplesimutilsCheck = new OptionalApplesimutilsCommandCheck();
class OptionalFfmpegCheck {
    log;
    static FFMPEG_BINARY = 'ffmpeg';
    static FFMPEG_INSTALL_LINK = 'https://www.ffmpeg.org/download.html';
    async diagnose() {
        const ffmpegPath = await (0, utils_1.resolveExecutablePath)(OptionalFfmpegCheck.FFMPEG_BINARY);
        return ffmpegPath
            ? support_1.doctor.okOptional(`${OptionalFfmpegCheck.FFMPEG_BINARY} exists at '${ffmpegPath}'`)
            : support_1.doctor.nokOptional(`${OptionalFfmpegCheck.FFMPEG_BINARY} cannot be found`);
    }
    async fix() {
        return (`${`${OptionalFfmpegCheck.FFMPEG_BINARY}`.bold} is used to capture screen recordings from the device under test. ` +
            `Please read ${OptionalFfmpegCheck.FFMPEG_INSTALL_LINK}.`);
    }
    hasAutofix() {
        return false;
    }
    isOptional() {
        return true;
    }
}
exports.OptionalFfmpegCheck = OptionalFfmpegCheck;
exports.optionalFfmpegCheck = new OptionalFfmpegCheck();
//# sourceMappingURL=optional-checks.js.map